{"version":3,"file":"TileLayer-D9SmqCHO.js","sources":["../../node_modules/ol/Tile.js","../../node_modules/ol/ImageTile.js","../../node_modules/ol/reproj/Tile.js","../../node_modules/ol/structs/LRUCache.js","../../node_modules/ol/tilecoord.js","../../node_modules/ol/TileCache.js","../../node_modules/ol/source/TileEventType.js","../../node_modules/ol/TileRange.js","../../node_modules/ol/tilegrid/TileGrid.js","../../node_modules/ol/tilegrid.js","../../node_modules/ol/source/Tile.js","../../node_modules/ol/tileurlfunction.js","../../node_modules/ol/source/UrlTile.js","../../node_modules/ol/layer/TileProperty.js","../../node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/Tile\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport TileState from './TileState.js';\nimport {abstract} from './util.js';\nimport {easeIn} from './easing.js';\n\n/**\n * A function that takes an {@link module:ol/Tile~Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from 'ol/TileState.js';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   const xhr = new XMLHttpRequest();\n *   xhr.responseType = 'blob';\n *   xhr.addEventListener('loadend', function (evt) {\n *     const data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener('error', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open('GET', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string): void} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection~Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import(\"./tilecoord.js\").TileCoord, number,\n *           import(\"./proj/Projection.js\").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\nclass Tile extends EventTarget {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"./tilecoord.js\").TileCoord}\n     */\n    this.tileCoord = tileCoord;\n\n    /**\n     * @protected\n     * @type {import(\"./TileState.js\").default}\n     */\n    this.state = state;\n\n    /**\n     * An \"interim\" tile for this tile. The interim tile may be used while this\n     * one is loading, for \"smooth\" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile|null}\n     */\n    this.interimTile = null;\n\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n    this.key = '';\n\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n    this.transition_ =\n      options.transition === undefined ? 250 : options.transition;\n\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n    this.transitionStarts_ = {};\n\n    /**\n     * @type {boolean}\n     */\n    this.interpolate = !!options.interpolate;\n  }\n\n  /**\n   * @protected\n   */\n  changed() {\n    this.dispatchEvent(EventType.CHANGE);\n  }\n\n  /**\n   * Called by the tile cache when the tile is removed from the cache due to expiry\n   */\n  release() {\n    if (this.state === TileState.ERROR) {\n      // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`\n      this.setState(TileState.EMPTY);\n    }\n  }\n\n  /**\n   * @return {string} Key.\n   */\n  getKey() {\n    return this.key + '/' + this.tileCoord;\n  }\n\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n  getInterimTile() {\n    let tile = this.interimTile;\n    if (!tile) {\n      //empty chain\n      return this;\n    }\n\n    // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        // Show tile immediately instead of fading it in after loading, because\n        // the interim tile is in place already\n        this.transition_ = 0;\n        return tile;\n      }\n      tile = tile.interimTile;\n    } while (tile);\n\n    // we can not find a better tile\n    return this;\n  }\n\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n  refreshInterimChain() {\n    let tile = this.interimTile;\n    if (!tile) {\n      return;\n    }\n\n    /** @type {Tile} */\n    let prev = this;\n    do {\n      if (tile.getState() == TileState.LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      }\n      if (tile.getState() == TileState.LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we're still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState.IDLE) {\n        //the head of the list is the most current tile, we don't need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n      tile = prev.interimTile;\n    } while (tile);\n  }\n\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import(\"./tilecoord.js\").TileCoord} The tile coordinate.\n   * @api\n   */\n  getTileCoord() {\n    return this.tileCoord;\n  }\n\n  /**\n   * @return {import(\"./TileState.js\").default} State.\n   */\n  getState() {\n    return this.state;\n  }\n\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @api\n   */\n  setState(state) {\n    if (this.state !== TileState.ERROR && this.state > state) {\n      throw new Error('Tile load sequence violation');\n    }\n    this.state = state;\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n  load() {\n    abstract();\n  }\n\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n  getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    let start = this.transitionStarts_[id];\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    const delta = time - start + 1000 / 60; // avoid rendering at 0\n    if (delta >= this.transition_) {\n      return 1;\n    }\n    return easeIn(delta / this.transition_);\n  }\n\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n  inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n    return this.transitionStarts_[id] !== -1;\n  }\n\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n  endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  }\n}\n\nexport default Tile;\n","/**\n * @module ol/ImageTile\n */\nimport Tile from './Tile.js';\nimport TileState from './TileState.js';\nimport {createCanvasContext2D} from './dom.js';\nimport {listenImage} from './Image.js';\n\nclass ImageTile extends Tile {\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"./TileState.js\").default} state State.\n   * @param {string} src Image source URI.\n   * @param {?string} crossOrigin Cross origin.\n   * @param {import(\"./Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @param {import(\"./Tile.js\").Options} [options] Tile options.\n   */\n  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {\n    super(tileCoord, state, options);\n\n    /**\n     * @private\n     * @type {?string}\n     */\n    this.crossOrigin_ = crossOrigin;\n\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n    this.src_ = src;\n\n    this.key = src;\n\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n    this.image_ = new Image();\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n\n    /**\n     * @private\n     * @type {?function():void}\n     */\n    this.unlisten_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n  getImage() {\n    return this.image_;\n  }\n\n  /**\n   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).\n   * @param {HTMLCanvasElement|HTMLImageElement} element Element.\n   */\n  setImage(element) {\n    this.image_ = element;\n    this.state = TileState.LOADED;\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n  handleImageError_() {\n    this.state = TileState.ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  }\n\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n  handleImageLoad_() {\n    const image = /** @type {HTMLImageElement} */ (this.image_);\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState.LOADED;\n    } else {\n      this.state = TileState.EMPTY;\n    }\n    this.unlistenImage_();\n    this.changed();\n  }\n\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   *\n   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`\n   * that checks for error status codes and reloads only when the status code is\n   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been\n   * made already:\n   *\n   * ```js\n   * const retryCodes = [408, 429, 500, 502, 503, 504];\n   * const retries = {};\n   * source.setTileLoadFunction((tile, src) => {\n   *   const image = tile.getImage();\n   *   fetch(src)\n   *     .then((response) => {\n   *       if (retryCodes.includes(response.status)) {\n   *         retries[src] = (retries[src] || 0) + 1;\n   *         if (retries[src] <= 3) {\n   *           setTimeout(() => tile.load(), retries[src] * 1000);\n   *         }\n   *         return Promise.reject();\n   *       }\n   *       return response.blob();\n   *     })\n   *     .then((blob) => {\n   *       const imageUrl = URL.createObjectURL(blob);\n   *       image.src = imageUrl;\n   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);\n   *     })\n   *     .catch(() => tile.setState(3)); // error\n   * });\n   * ```\n   *\n   * @api\n   */\n  load() {\n    if (this.state == TileState.ERROR) {\n      this.state = TileState.IDLE;\n      this.image_ = new Image();\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      this.tileLoadFunction_(this, this.src_);\n      this.unlisten_ = listenImage(\n        this.image_,\n        this.handleImageLoad_.bind(this),\n        this.handleImageError_.bind(this)\n      );\n    }\n  }\n\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n  unlistenImage_() {\n    if (this.unlisten_) {\n      this.unlisten_();\n      this.unlisten_ = null;\n    }\n  }\n}\n\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\nfunction getBlankImage() {\n  const ctx = createCanvasContext2D(1, 1);\n  ctx.fillStyle = 'rgba(0,0,0,0)';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\nexport default ImageTile;\n","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceExtentResolution,\n  canvasPool,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {clamp} from '../math.js';\nimport {getArea, getIntersection} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport {releaseCanvas} from '../dom.js';\n\n/**\n * @typedef {function(number, number, number, number) : (import(\"../ImageTile.js\").default)} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number} [errorThreshold] Acceptable reprojection error (in px).\n   * @param {boolean} [renderEdges] Render reprojection edges.\n   * @param {import(\"../Tile.js\").Options} [options] Tile options.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    errorThreshold,\n    renderEdges,\n    options\n  ) {\n    super(tileCoord, TileState.IDLE, options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../ImageTile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {?Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(\n      this.wrappedTileCoord_\n    );\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]\n    );\n\n    const sourceResolution = calculateSourceExtentResolution(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      targetResolution\n    );\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels =\n      errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n        sourceExtent[3] = clamp(\n          sourceExtent[3],\n          maxSourceExtent[1],\n          maxSourceExtent[3]\n        );\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent,\n        this.sourceZ_\n      );\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach((tile) => {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage(),\n        });\n      }\n    });\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(\n        this.sourceZ_\n      );\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_\n      );\n\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.pixelRatio_,\n        sourceResolution,\n        this.sourceTileGrid_.getExtent(),\n        targetResolution,\n        targetExtent,\n        this.triangulation_,\n        sources,\n        this.gutter_,\n        this.renderEdges_,\n        this.interpolate\n      );\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach((tile) => {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(\n            tile,\n            EventType.CHANGE,\n            function (e) {\n              const state = tile.getState();\n              if (\n                state == TileState.LOADED ||\n                state == TileState.ERROR ||\n                state == TileState.EMPTY\n              ) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            },\n            this\n          );\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      } else {\n        this.sourceTiles_.forEach(function (tile, i, arr) {\n          const state = tile.getState();\n          if (state == TileState.IDLE) {\n            tile.load();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n\n  /**\n   * Remove from the cache due to expiry\n   */\n  release() {\n    if (this.canvas_) {\n      releaseCanvas(this.canvas_.getContext('2d'));\n      canvasPool.push(this.canvas_);\n      this.canvas_ = null;\n    }\n    super.release();\n  }\n}\n\nexport default ReprojTile;\n","/**\n * @module ol/structs/LRUCache\n */\n\nimport {assert} from '../asserts.js';\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_ Key.\n * @property {Entry|null} newer Newer.\n * @property {Entry|null} older Older.\n * @property {*} value_ Value.\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import(\"../events/Event.js\").default\n * @template T\n */\nclass LRUCache {\n  /**\n   * @param {number} [highWaterMark] High water mark.\n   */\n  constructor(highWaterMark) {\n    /**\n     * Desired max cache size after expireCache(). If set to 0, no cache entries\n     * will be pruned at all.\n     * @type {number}\n     */\n    this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.count_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.oldest_ = null;\n\n    /**\n     * @private\n     * @type {?Entry}\n     */\n    this.newest_ = null;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;\n  }\n\n  /**\n   * Expire the cache.\n   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.\n   */\n  expireCache(keep) {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n  containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  }\n\n  /**\n   * @param {function(T, string, LRUCache<T>): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   */\n  forEach(f) {\n    let entry = this.oldest_;\n    while (entry) {\n      f(entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {*} [options] Options (reserved for subclasses).\n   * @return {T} Value.\n   */\n  get(key, options) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache'\n    );\n    if (entry === this.newest_) {\n      return entry.value_;\n    }\n    if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  }\n\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n  remove(key) {\n    const entry = this.entries_[key];\n    assert(\n      entry !== undefined,\n      'Tried to get a value for a key that does not exist in the cache'\n    );\n    if (entry === this.newest_) {\n      this.newest_ = /** @type {Entry} */ (entry.older);\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ = /** @type {Entry} */ (entry.newer);\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @return {number} Count.\n   */\n  getCount() {\n    return this.count_;\n  }\n\n  /**\n   * @return {Array<string>} Keys.\n   */\n  getKeys() {\n    const keys = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n    return keys;\n  }\n\n  /**\n   * @return {Array<T>} Values.\n   */\n  getValues() {\n    const values = new Array(this.count_);\n    let i = 0;\n    let entry;\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n    return values;\n  }\n\n  /**\n   * @return {T} Last value.\n   */\n  peekLast() {\n    return this.oldest_.value_;\n  }\n\n  /**\n   * @return {string} Last key.\n   */\n  peekLastKey() {\n    return this.oldest_.key_;\n  }\n\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n  peekFirstKey() {\n    return this.newest_.key_;\n  }\n\n  /**\n   * Return an entry without updating least recently used time.\n   * @param {string} key Key.\n   * @return {T|undefined} Value.\n   */\n  peek(key) {\n    return this.entries_[key]?.value_;\n  }\n\n  /**\n   * @return {T} value Value.\n   */\n  pop() {\n    const entry = this.oldest_;\n    delete this.entries_[entry.key_];\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n    this.oldest_ = /** @type {Entry} */ (entry.newer);\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n    --this.count_;\n    return entry.value_;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  replace(key, value) {\n    this.get(key); // update `newest_`\n    this.entries_[key].value_ = value;\n  }\n\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n  set(key, value) {\n    assert(\n      !(key in this.entries_),\n      'Tried to set a value for a key that is used already'\n    );\n    const entry = {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value,\n    };\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  }\n\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n  setSize(size) {\n    this.highWaterMark = size;\n  }\n}\n\nexport default LRUCache;\n","/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  }\n  return [z, x, y];\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  }\n  return tileRange.containsXY(x, y);\n}\n","/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach((tile) => {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    });\n  }\n}\n\nexport default TileCache;\n","/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: 'tileloadstart',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: 'tileloadend',\n\n  /**\n   * Triggered if tile loading results in an error. Note that this is not the\n   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}\n   * for details.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: 'tileloaderror',\n};\n\n/**\n * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes\n */\n","/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  }\n  return new TileRange(minX, maxX, minY, maxY);\n}\n\nexport default TileRange;\n","/**\n * @module ol/tilegrid/TileGrid\n */\nimport TileRange, {\n  createOrUpdate as createOrUpdateTileRange,\n} from '../TileRange.js';\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport {ceil, clamp, floor} from '../math.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\nimport {intersectsLinearRing} from '../geom/flat/intersectsextent.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {toSize} from '../size.js';\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nconst tmpTileCoord = [0, 0, 0];\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nconst DECIMALS = 5;\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Number of tile rows and columns\n * of the grid for each zoom level. If specified the values\n * define each zoom level's extent together with the `origin` or `origins`.\n * A grid `extent` can be configured in addition, and will further limit the extent\n * for which tile requests are made by sources. If the bottom-left corner of\n * an extent is used as `origin` or `origins`, then the `y` value must be\n * negative because OpenLayers tile coordinates use the top left as the origin.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<number|import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nclass TileGrid {\n  /**\n   * @param {Options} options Tile grid options.\n   */\n  constructor(options) {\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n    /**\n     * @private\n     * @type {!Array<number>}\n     */\n    this.resolutions_ = options.resolutions;\n    assert(\n      isSorted(\n        this.resolutions_,\n        /**\n         * @param {number} a First resolution\n         * @param {number} b Second resolution\n         * @return {number} Comparison result\n         */\n        (a, b) => b - a,\n        true\n      ),\n      '`resolutions` must be sorted in descending order'\n    );\n\n    // check if we've got a consistent zoom factor and origin\n    let zoomFactor;\n    if (!options.origins) {\n      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n        if (!zoomFactor) {\n          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n        } else {\n          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n            zoomFactor = undefined;\n            break;\n          }\n        }\n      }\n    }\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.zoomFactor_ = zoomFactor;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxZoom = this.resolutions_.length - 1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.origin_ = options.origin !== undefined ? options.origin : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../coordinate.js\").Coordinate>}\n     */\n    this.origins_ = null;\n    if (options.origins !== undefined) {\n      this.origins_ = options.origins;\n      assert(\n        this.origins_.length == this.resolutions_.length,\n        'Number of `origins` and `resolutions` must be equal'\n      );\n    }\n\n    const extent = options.extent;\n\n    if (extent !== undefined && !this.origin_ && !this.origins_) {\n      this.origin_ = getTopLeft(extent);\n    }\n\n    assert(\n      (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n      'Either `origin` or `origins` must be configured, never both'\n    );\n\n    /**\n     * @private\n     * @type {Array<number|import(\"../size.js\").Size>}\n     */\n    this.tileSizes_ = null;\n    if (options.tileSizes !== undefined) {\n      this.tileSizes_ = options.tileSizes;\n      assert(\n        this.tileSizes_.length == this.resolutions_.length,\n        'Number of `tileSizes` and `resolutions` must be equal'\n      );\n    }\n\n    /**\n     * @private\n     * @type {number|import(\"../size.js\").Size}\n     */\n    this.tileSize_ =\n      options.tileSize !== undefined\n        ? options.tileSize\n        : !this.tileSizes_\n        ? DEFAULT_TILE_SIZE\n        : null;\n    assert(\n      (!this.tileSize_ && this.tileSizes_) ||\n        (this.tileSize_ && !this.tileSizes_),\n      'Either `tileSize` or `tileSizes` must be configured, never both'\n    );\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = extent !== undefined ? extent : null;\n\n    /**\n     * @private\n     * @type {Array<import(\"../TileRange.js\").default>}\n     */\n    this.fullTileRanges_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize_ = [0, 0];\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = [0, 0, 0, 0];\n\n    if (options.sizes !== undefined) {\n      this.fullTileRanges_ = options.sizes.map((size, z) => {\n        const tileRange = new TileRange(\n          Math.min(0, size[0]),\n          Math.max(size[0] - 1, -1),\n          Math.min(0, size[1]),\n          Math.max(size[1] - 1, -1)\n        );\n        if (extent) {\n          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);\n          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);\n          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);\n          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);\n          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);\n        }\n        return tileRange;\n      });\n    } else if (extent) {\n      this.calculateTileRanges_(extent);\n    }\n  }\n\n  /**\n   * Call a function with each tile coordinate for a given extent and zoom level.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} zoom Integer zoom level.\n   * @param {function(import(\"../tilecoord.js\").TileCoord): void} callback Function called with each tile coordinate.\n   * @api\n   */\n  forEachTileCoord(extent, zoom, callback) {\n    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n        callback([zoom, i, j]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {function(number, import(\"../TileRange.js\").default): boolean} callback Callback.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {boolean} Callback succeeded.\n   */\n  forEachTileCoordParentTileRange(\n    tileCoord,\n    callback,\n    tempTileRange,\n    tempExtent\n  ) {\n    let tileRange, x, y;\n    let tileCoordExtent = null;\n    let z = tileCoord[0] - 1;\n    if (this.zoomFactor_ === 2) {\n      x = tileCoord[1];\n      y = tileCoord[2];\n    } else {\n      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);\n    }\n    while (z >= this.minZoom) {\n      if (x !== undefined && y !== undefined) {\n        x = Math.floor(x / 2);\n        y = Math.floor(y / 2);\n        tileRange = createOrUpdateTileRange(x, x, y, y, tempTileRange);\n      } else {\n        tileRange = this.getTileRangeForExtentAndZ(\n          tileCoordExtent,\n          z,\n          tempTileRange\n        );\n      }\n      if (callback(z, tileRange)) {\n        return true;\n      }\n      --z;\n    }\n    return false;\n  }\n\n  /**\n   * Get the extent for this tile grid, if it was configured.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the maximum zoom level for the grid.\n   * @return {number} Max zoom.\n   * @api\n   */\n  getMaxZoom() {\n    return this.maxZoom;\n  }\n\n  /**\n   * Get the minimum zoom level for the grid.\n   * @return {number} Min zoom.\n   * @api\n   */\n  getMinZoom() {\n    return this.minZoom;\n  }\n\n  /**\n   * Get the origin for the grid at the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {import(\"../coordinate.js\").Coordinate} Origin.\n   * @api\n   */\n  getOrigin(z) {\n    if (this.origin_) {\n      return this.origin_;\n    }\n    return this.origins_[z];\n  }\n\n  /**\n   * Get the resolution for the given zoom level.\n   * @param {number} z Integer zoom level.\n   * @return {number} Resolution.\n   * @api\n   */\n  getResolution(z) {\n    return this.resolutions_[z];\n  }\n\n  /**\n   * Get the list of resolutions for the tile grid.\n   * @return {Array<number>} Resolutions.\n   * @api\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary import(\"../extent.js\").Extent object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {\n    if (tileCoord[0] < this.maxZoom) {\n      if (this.zoomFactor_ === 2) {\n        const minX = tileCoord[1] * 2;\n        const minY = tileCoord[2] * 2;\n        return createOrUpdateTileRange(\n          minX,\n          minX + 1,\n          minY,\n          minY + 1,\n          tempTileRange\n        );\n      }\n      const tileCoordExtent = this.getTileCoordExtent(\n        tileCoord,\n        tempExtent || this.tmpExtent_\n      );\n      return this.getTileRangeForExtentAndZ(\n        tileCoordExtent,\n        tileCoord[0] + 1,\n        tempTileRange\n      );\n    }\n    return null;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary import(\"../TileRange.js\").default object.\n   * @return {import(\"../TileRange.js\").default|null} Tile range.\n   */\n  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {\n    if (z > this.maxZoom || z < this.minZoom) {\n      return null;\n    }\n\n    const tileCoordZ = tileCoord[0];\n    const tileCoordX = tileCoord[1];\n    const tileCoordY = tileCoord[2];\n\n    if (z === tileCoordZ) {\n      return createOrUpdateTileRange(\n        tileCoordX,\n        tileCoordY,\n        tileCoordX,\n        tileCoordY,\n        tempTileRange\n      );\n    }\n\n    if (this.zoomFactor_) {\n      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);\n      const minX = Math.floor(tileCoordX * factor);\n      const minY = Math.floor(tileCoordY * factor);\n      if (z < tileCoordZ) {\n        return createOrUpdateTileRange(minX, minX, minY, minY, tempTileRange);\n      }\n\n      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;\n      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;\n      return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n    }\n\n    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);\n  }\n\n  /**\n   * Get a tile range for the given extent and integer zoom level.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} z Integer zoom level.\n   * @param {import(\"../TileRange.js\").default} [tempTileRange] Temporary tile range object.\n   * @return {import(\"../TileRange.js\").default} Tile range.\n   */\n  getTileRangeForExtentAndZ(extent, z, tempTileRange) {\n    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);\n    const minX = tmpTileCoord[1];\n    const minY = tmpTileCoord[2];\n    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);\n    const maxX = tmpTileCoord[1];\n    const maxY = tmpTileCoord[2];\n    return createOrUpdateTileRange(minX, maxX, minY, maxY, tempTileRange);\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n   */\n  getTileCoordCenter(tileCoord) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    return [\n      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,\n    ];\n  }\n\n  /**\n   * Get the extent of a tile coordinate.\n   *\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} [tempExtent] Temporary extent object.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getTileCoordExtent(tileCoord, tempExtent) {\n    const origin = this.getOrigin(tileCoord[0]);\n    const resolution = this.getResolution(tileCoord[0]);\n    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;\n    const maxX = minX + tileSize[0] * resolution;\n    const maxY = minY + tileSize[1] * resolution;\n    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);\n  }\n\n  /**\n   * Get the tile coordinate for the given map coordinate and resolution.  This\n   * method considers that coordinates that intersect tile boundaries should be\n   * assigned the higher tile coordinate.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n    return this.getTileCoordForXYAndResolution_(\n      coordinate[0],\n      coordinate[1],\n      resolution,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * Note that this method should not be called for resolutions that correspond\n   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {number} resolution Resolution (for a non-integer zoom level).\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndResolution_(\n    x,\n    y,\n    resolution,\n    reverseIntersectionPolicy,\n    opt_tileCoord\n  ) {\n    const z = this.getZForResolution(resolution);\n    const scale = resolution / this.getResolution(z);\n    const origin = this.getOrigin(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (scale * (x - origin[0])) / resolution / tileSize[0];\n    let tileCoordY = (scale * (origin[1] - y)) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n   * they should have separate implementations.  This method is for integer zoom\n   * levels.  The other method should only be called for resolutions corresponding\n   * to non-integer zoom levels.\n   * @param {number} x Map x coordinate.\n   * @param {number} y Map y coordinate.\n   * @param {number} z Integer zoom level.\n   * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n   *     intersections go to the higher tile coordinate, let edge intersections\n   *     go to the lower tile coordinate.\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Temporary import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @private\n   */\n  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n    const origin = this.getOrigin(z);\n    const resolution = this.getResolution(z);\n    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];\n    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];\n\n    if (reverseIntersectionPolicy) {\n      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;\n      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;\n    } else {\n      tileCoordX = floor(tileCoordX, DECIMALS);\n      tileCoordY = floor(tileCoordY, DECIMALS);\n    }\n\n    return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n  }\n\n  /**\n   * Get a tile coordinate given a map coordinate and zoom level.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call\n   * @param {import(\"../tilecoord.js\").TileCoord} [opt_tileCoord] Destination import(\"../tilecoord.js\").TileCoord object.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n   * @api\n   */\n  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n    return this.getTileCoordForXYAndZ_(\n      coordinate[0],\n      coordinate[1],\n      z,\n      false,\n      opt_tileCoord\n    );\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {number} Tile resolution.\n   */\n  getTileCoordResolution(tileCoord) {\n    return this.resolutions_[tileCoord[0]];\n  }\n\n  /**\n   * Get the tile size for a zoom level. The type of the return value matches the\n   * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n   * get an {@link import(\"../size.js\").Size}, run the result through {@link module:ol/size.toSize}.\n   * @param {number} z Z.\n   * @return {number|import(\"../size.js\").Size} Tile size.\n   * @api\n   */\n  getTileSize(z) {\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    return this.tileSizes_[z];\n  }\n\n  /**\n   * @param {number} z Zoom level.\n   * @return {import(\"../TileRange.js\").default|null} Extent tile range for the specified zoom level.\n   */\n  getFullTileRange(z) {\n    if (!this.fullTileRanges_) {\n      return this.extent_\n        ? this.getTileRangeForExtentAndZ(this.extent_, z)\n        : null;\n    }\n    return this.fullTileRanges_[z];\n  }\n\n  /**\n   * @param {number} resolution Resolution.\n   * @param {number|import(\"../array.js\").NearestDirectionFunction} [opt_direction]\n   *     If 0, the nearest resolution will be used.\n   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the\n   *     nearest lower resolution (higher Z) will be used. Default is 0.\n   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.\n   *\n   * For example to change tile Z at the midpoint of zoom levels\n   * ```js\n   * function(value, high, low) {\n   *   return value - low * Math.sqrt(high / low);\n   * }\n   * ```\n   * @return {number} Z.\n   * @api\n   */\n  getZForResolution(resolution, opt_direction) {\n    const z = linearFindNearest(\n      this.resolutions_,\n      resolution,\n      opt_direction || 0\n    );\n    return clamp(z, this.minZoom, this.maxZoom);\n  }\n\n  /**\n   * The tile with the provided tile coordinate intersects the given viewport.\n   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.\n   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.\n   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.\n   */\n  tileCoordIntersectsViewport(tileCoord, viewport) {\n    return intersectsLinearRing(\n      viewport,\n      0,\n      viewport.length,\n      2,\n      this.getTileCoordExtent(tileCoord)\n    );\n  }\n\n  /**\n   * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n   * @private\n   */\n  calculateTileRanges_(extent) {\n    const length = this.resolutions_.length;\n    const fullTileRanges = new Array(length);\n    for (let z = this.minZoom; z < length; ++z) {\n      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n    }\n    this.fullTileRanges_ = fullTileRanges;\n  }\n}\n\nexport default TileGrid;\n","/**\n * @module ol/tilegrid\n */\nimport TileGrid from './tilegrid/TileGrid.js';\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {METERS_PER_UNIT, get as getProjection} from './proj.js';\nimport {\n  containsCoordinate,\n  createOrUpdate,\n  getCorner,\n  getHeight,\n  getWidth,\n} from './extent.js';\nimport {toSize} from './size.js';\n\nexport {TileGrid};\nexport {default as WMTS} from './tilegrid/WMTS.js';\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  let tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  const z = tileCoord[0];\n  const center = tileGrid.getTileCoordCenter(tileCoord);\n  const projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.ceil(\n      (projectionExtent[0] - center[0]) / worldWidth\n    );\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  }\n  return tileCoord;\n}\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, maxZoom, tileSize, corner) {\n  corner = corner !== undefined ? corner : 'top-left';\n\n  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: tileSize,\n  });\n}\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution\n * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxResolution] Resolution at level zero.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions} [options] Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(options) {\n  const xyzOptions = options || {};\n\n  const extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  const gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize,\n      xyzOptions.maxResolution\n    ),\n  };\n  return new TileGrid(gridOptions);\n}\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {number} [maxResolution] Resolution at level zero.\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {\n  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;\n  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);\n\n  const height = getHeight(extent);\n  const width = getWidth(extent);\n\n  maxResolution =\n    maxResolution > 0\n      ? maxResolution\n      : Math.max(width / tileSize[0], height / tileSize[1]);\n\n  const length = maxZoom + 1;\n  const resolutions = new Array(length);\n  for (let z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number} [maxZoom] Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size} [tileSize] Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {import(\"./extent.js\").Corner} [corner] Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, maxZoom, tileSize, corner) {\n  const extent = extentFromProjection(projection);\n  return createForExtent(extent, maxZoom, tileSize, corner);\n}\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  let extent = projection.getExtent();\n  if (!extent) {\n    const half =\n      (180 * METERS_PER_UNIT.degrees) / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n","/**\n * @module ol/source/Tile\n */\nimport Event from '../events/Event.js';\nimport Source from './Source.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport {abstract} from '../util.js';\nimport {assert} from '../asserts.js';\nimport {equivalent} from '../proj.js';\nimport {getKeyZXY, withinExtentAndZ} from '../tilecoord.js';\nimport {\n  getForProjection as getTileGridForProjection,\n  wrapX,\n} from '../tilegrid.js';\nimport {scale as scaleSize, toSize} from '../size.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./TileEventType\").TileSourceEventTypes, TileSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     import(\"./TileEventType\").TileSourceEventTypes, Return>} TileSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] CacheSize.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {boolean} [wrapX=false] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\nclass TileSource extends Source {\n  /**\n   * @param {Options} options SourceTile source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX,\n      interpolate: options.interpolate,\n    });\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {TileSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {TileSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilePixelRatio_ =\n      options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n\n    /**\n     * @type {import(\"../tilegrid/TileGrid.js\").default|null}\n     */\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n\n    const tileSize = [256, 256];\n    if (this.tileGrid) {\n      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);\n    }\n\n    /**\n     * @protected\n     * @type {import(\"../TileCache.js\").default}\n     */\n    this.tileCache = new TileCache(options.cacheSize || 0);\n\n    /**\n     * @protected\n     * @type {import(\"../size.js\").Size}\n     */\n    this.tmpSize = [0, 0];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.key_ = options.key || '';\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").Options}\n     */\n    this.tileOptions = {\n      transition: options.transition,\n      interpolate: options.interpolate,\n    };\n\n    /**\n     * zDirection hint, read by the renderer. Indicates which resolution should be used\n     * by a renderer if the views resolution does not match any resolution of the tile source.\n     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n     * will be used. If -1, the nearest higher resolution will be used.\n     * @type {number|import(\"../array.js\").NearestDirectionFunction}\n     */\n    this.zDirection = options.zDirection ? options.zDirection : 0;\n  }\n\n  /**\n   * @return {boolean} Can expire cache.\n   */\n  canExpireCache() {\n    return this.tileCache.canExpireCache();\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(projection, usedTiles) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @param {function(import(\"../Tile.js\").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n  forEachLoadedTile(projection, z, tileRange, callback) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (!tileCache) {\n      return false;\n    }\n\n    let covered = true;\n    let tile, tileCoordKey, loaded;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = getKeyZXY(z, x, y);\n        loaded = false;\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile = /** @type {!import(\"../Tile.js\").default} */ (\n            tileCache.get(tileCoordKey)\n          );\n          loaded = tile.getState() === TileState.LOADED;\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   */\n  getGutterForProjection(projection) {\n    return 0;\n  }\n\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   */\n  getKey() {\n    return this.key_;\n  }\n\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n  setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n  getOpaque(projection) {\n    return this.opaque_;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions(projection) {\n    const tileGrid = projection\n      ? this.getTileGridForProjection(projection)\n      : this.tileGrid;\n    if (!tileGrid) {\n      return null;\n    }\n    return tileGrid.getResolutions();\n  }\n\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    return abstract();\n  }\n\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import(\"../tilegrid/TileGrid.js\").default|null} Tile grid.\n   * @api\n   */\n  getTileGrid() {\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n  getTileGridForProjection(projection) {\n    if (!this.tileGrid) {\n      return getTileGridForProjection(projection);\n    }\n    return this.tileGrid;\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @protected\n   */\n  getTileCacheForProjection(projection) {\n    const sourceProjection = this.getProjection();\n    assert(\n      sourceProjection === null || equivalent(sourceProjection, projection),\n      'A VectorTile source can only be rendered if it has a projection compatible with the view projection.'\n    );\n    return this.tileCache;\n  }\n\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  }\n\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n  getTilePixelSize(z, pixelRatio, projection) {\n    const tileGrid = this.getTileGridForProjection(projection);\n    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    }\n    return scaleSize(tileSize, tilePixelRatio, this.tmpSize);\n  }\n\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../proj/Projection.js\").default} [projection] Projection.\n   * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n  getTileCoordForTileUrlFunction(tileCoord, projection) {\n    projection = projection !== undefined ? projection : this.getProjection();\n    const tileGrid = this.getTileGridForProjection(projection);\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = wrapX(tileGrid, tileCoord, projection);\n    }\n    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;\n  }\n\n  /**\n   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.\n   * @api\n   */\n  clear() {\n    this.tileCache.clear();\n  }\n\n  refresh() {\n    this.clear();\n    super.refresh();\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  updateCacheSize(tileCount, projection) {\n    const tileCache = this.getTileCacheForProjection(projection);\n    if (tileCount > tileCache.highWaterMark) {\n      tileCache.highWaterMark = tileCount;\n    }\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  useTile(z, x, y, projection) {}\n}\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\nexport class TileSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Tile.js\").default} tile The tile.\n   */\n  constructor(type, tile) {\n    super(type);\n\n    /**\n     * The tile related to the event.\n     * @type {import(\"../Tile.js\").default}\n     * @api\n     */\n    this.tile = tile;\n  }\n}\n\nexport default TileSource;\n","/**\n * @module ol/tileurlfunction\n */\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  const zRegEx = /\\{z\\}/g;\n  const xRegEx = /\\{x\\}/g;\n  const yRegEx = /\\{y\\}/g;\n  const dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      return template\n        .replace(zRegEx, tileCoord[0].toString())\n        .replace(xRegEx, tileCoord[1].toString())\n        .replace(yRegEx, tileCoord[2].toString())\n        .replace(dashYRegEx, function () {\n          const z = tileCoord[0];\n          const range = tileGrid.getFullTileRange(z);\n          if (!range) {\n            throw new Error(\n              'The {-y} placeholder requires a tile grid with extent'\n            );\n          }\n          const y = range.getHeight() - tileCoord[2] - 1;\n          return y.toString();\n        });\n    }\n  );\n}\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  const len = templates.length;\n  const tileUrlFunctions = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      }\n      const h = tileCoordHash(tileCoord);\n      const index = modulo(h, tileUrlFunctions.length);\n      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n    }\n  );\n}\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  const urls = [];\n  let match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    const startCharCode = match[1].charCodeAt(0);\n    const stopCharCode = match[2].charCodeAt(0);\n    let charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    const stop = parseInt(match[2], 10);\n    for (let i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n","/**\n * @module ol/source/UrlTile\n */\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {createFromTemplates, expandUrl} from '../tileurlfunction.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Cache size.\n * @property {boolean} [opaque=false] Whether the layer is opaque.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {import(\"./Source.js\").State} [state] State.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] TileGrid.\n * @property {import(\"../Tile.js\").LoadFunction} tileLoadFunction TileLoadFunction.\n * @property {number} [tilePixelRatio] TilePixelRatio.\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] TileUrlFunction.\n * @property {string} [url] Url.\n * @property {Array<string>} [urls] Urls.\n * @property {boolean} [wrapX=true] WrapX.\n * @property {number} [transition] Transition.\n * @property {string} [key] Key.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0] ZDirection.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n */\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n */\nclass UrlTile extends TileSource {\n  /**\n   * @param {Options} options Image tile options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.generateTileUrlFunction_ =\n      this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;\n\n    /**\n     * @protected\n     * @type {import(\"../Tile.js\").LoadFunction}\n     */\n    this.tileLoadFunction = options.tileLoadFunction;\n\n    if (options.tileUrlFunction) {\n      this.tileUrlFunction = options.tileUrlFunction;\n    }\n\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n  }\n\n  /**\n   * Return the tile load function of the source.\n   * @return {import(\"../Tile.js\").LoadFunction} TileLoadFunction\n   * @api\n   */\n  getTileLoadFunction() {\n    return this.tileLoadFunction;\n  }\n\n  /**\n   * Return the tile URL function of the source.\n   * @return {import(\"../Tile.js\").UrlFunction} TileUrlFunction\n   * @api\n   */\n  getTileUrlFunction() {\n    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction\n      ? this.tileUrlFunction.bind(this)\n      : this.tileUrlFunction;\n  }\n\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n  getUrls() {\n    return this.urls;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n          ? TileEventType.TILELOADEND\n          : undefined;\n    }\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * Set the tile load function of the source.\n   * @param {import(\"../Tile.js\").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n  setTileLoadFunction(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  }\n\n  /**\n   * Set the tile URL function of the source.\n   * @param {import(\"../Tile.js\").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string} [key] Optional new tile key for the source.\n   * @api\n   */\n  setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n    if (typeof key !== 'undefined') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  }\n\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n  setUrl(url) {\n    const urls = expandUrl(url);\n    this.urls = urls;\n    this.setUrls(urls);\n  }\n\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n  setUrls(urls) {\n    this.urls = urls;\n    const key = urls.join('\\n');\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {string|undefined} Tile URL.\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    return undefined;\n  }\n\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   */\n  useTile(z, x, y) {\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  }\n}\n\nexport default UrlTile;\n","/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  PRELOAD: 'preload',\n  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',\n};\n","/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getHeight,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  getWidth,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice()\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0])\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1])\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection)\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    // desired dimensions of the canvas in pixels\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection)\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2\n    );\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n    const context = this.context;\n    const canvas = context.canvas;\n\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2\n    );\n\n    if (canvas.width != width || canvas.height != height) {\n      canvas.width = width;\n      canvas.height = height;\n    } else if (!this.containerReused) {\n      context.clearRect(0, 0, width, height);\n    }\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]]\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload()\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (canvasTransform !== canvas.style.transform) {\n      canvas.style.transform = canvasTransform;\n    }\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h\n    );\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        )\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"names":["Tile","EventTarget","tileCoord","state","options","EventType","TileState","tile","prev","abstract","id","time","start","delta","easeIn","ImageTile","src","crossOrigin","tileLoadFunction","element","getBlankImage","image","listenImage","ctx","createCanvasContext2D","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","wrappedTileCoord","pixelRatio","gutter","getTileFunction","errorThreshold","renderEdges","targetExtent","maxTargetExtent","maxSourceExtent","limitedTargetExtent","getIntersection","getArea","sourceProjExtent","targetResolution","sourceResolution","calculateSourceExtentResolution","errorThresholdInPixels","ERROR_THRESHOLD","Triangulation","sourceExtent","clamp","sourceRange","srcX","srcY","sources","z","size","width","height","renderReprojected","leftToLoad","sourceListenKey","listen","e","unlistenByKey","arr","releaseCanvas","canvasPool","LRUCache","highWaterMark","keep","key","f","entry","assert","keys","i","values","_a","value","createOrUpdate","x","y","getKeyZXY","getKey","getCacheKeyForTileKey","tileKey","fromKey","hash","withinExtentAndZ","tileGrid","tileRange","TileCache","usedTiles","TileEventType","TileRange","minX","maxX","minY","maxY","tmpTileCoord","DECIMALS","TileGrid","isSorted","a","b","zoomFactor","ii","extent","getTopLeft","DEFAULT_TILE_SIZE","restrictedTileRange","zoom","callback","j","jj","tempTileRange","tempExtent","tileCoordExtent","createOrUpdateTileRange","tileCoordZ","tileCoordX","tileCoordY","factor","origin","resolution","tileSize","toSize","coordinate","opt_tileCoord","reverseIntersectionPolicy","scale","ceil","floor","createOrUpdateTileCoord","opt_direction","linearFindNearest","viewport","intersectsLinearRing","length","fullTileRanges","getForProjection","projection","createForProjection","wrapX","center","projectionExtent","extentFromProjection","containsCoordinate","worldWidth","getWidth","worldsAway","createForExtent","maxZoom","corner","resolutions","resolutionsFromExtent","getCorner","createXYZ","xyzOptions","getProjection","gridOptions","maxResolution","DEFAULT_MAX_ZOOM","getHeight","half","METERS_PER_UNIT","TileSource","Source","tileCache","covered","tileCoordKey","loaded","getTileGridForProjection","sourceProjection","equivalent","tilePixelRatio","scaleSize","tileCount","TileSourceEvent","Event","type","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","range","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","tileCoordHash","index","modulo","expandUrl","url","urls","match","startCharCode","stopCharCode","charCode","stop","UrlTile","event","uid","getUid","tileState","tileUrlFunction","TileProperty","CanvasTileLayerRenderer","CanvasLayerRenderer","tileLayer","createEmpty","useInterimTilesOnError","frameState","pixel","layer","applyTransform","layerExtent","viewState","source","tileOrigin","tileResolution","col","row","tiles","target","layerState","viewResolution","viewCenter","rotation","tileSource","sourceRevision","fromUserExtent","dx","dy","canvasExtent","tilesToDrawByZ","findLoadedTiles","tmpExtent","tmpTileRange","getRotatedViewport","inTransition","childTileRange","canvasScale","composeTransform","canvasTransform","toTransformString","context","canvas","makeInverse","zs","ascending","clips","clipZs","currentClip","currentZ","currentTilePixelSize","currentScale","originTileCoord","originTileExtent","tileGutter","tilesToDraw","xIndex","nextX","yIndex","nextY","w","transition","contextSaved","clip","intersects","equals","alpha","alphaChanged","postRenderFunction","map","tileSourceKey","preload","tileCallback","wantedTiles","tileQueue","minZoom"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}